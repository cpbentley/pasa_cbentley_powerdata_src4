package pasa.cbentley.powerdata.src4.string;

import java.util.Vector;

import pasa.cbentley.byteobjects.src4.core.ByteController;
import pasa.cbentley.byteobjects.src4.core.ByteObjectManaged;
import pasa.cbentley.core.src4.helpers.StringBBuilder;
import pasa.cbentley.core.src4.structs.IntBuffer;
import pasa.cbentley.core.src4.structs.IntToStrings;
import pasa.cbentley.core.src4.utils.BitCoordinate;
import pasa.cbentley.core.src4.utils.BitUtils;
import pasa.cbentley.core.src4.utils.CharUtils;
import pasa.cbentley.core.src4.utils.IntUtils;
import pasa.cbentley.core.src4.utils.StringUtils;
import pasa.cbentley.powerdata.spec.src4.power.IPointerUser;
import pasa.cbentley.powerdata.spec.src4.power.IPowerCharCollector;
import pasa.cbentley.powerdata.spec.src4.power.MorphParams;
import pasa.cbentley.powerdata.spec.src4.power.integers.IPowerIntArrayOrderToInt;
import pasa.cbentley.powerdata.spec.src4.power.integers.IPowerLinkOrderedIntToInt;
import pasa.cbentley.powerdata.spec.src4.power.itech.ITechCharColRun;
import pasa.cbentley.powerdata.spec.src4.power.itech.ITechMorph;
import pasa.cbentley.powerdata.spec.src4.power.string.IPowerLinkStringToBytes;
import pasa.cbentley.powerdata.src4.ctx.PDCtx;

/**
 * {@link ByteObjectManaged} collecting char for {@link IPowerCharCollector}.
 * <br>
 * <br>
 * Sort Strings by length (Big Index) and then by FirstLetter (SmallIndex)
 * <br>
 * The pointer is the position of the String, starting at .
 * 
 * integer -> string linking
 * <br>
 * <br>
 * 
 * Accept only characters from a single plane (0 latin, 1 greek, 4 ciryllic)
 * <br>
 * <br>
 * 
 * DATA IMPLEMENTATION
 * <br>
 * 
 * These two sequences are located by the {@link ByteController}. Outside of our byte array
 * <br>
 * <br>
 * [start letters IntOSequenceTable] : Tracks the first letters : 
 * <br>
 * [all letters IntOSequenceTable] : bag of all letters used
 * <br>
 * <br>
 * [index offset] [seq offset]
 * <br>
 * <br>
 * 
 * (header) <br>
 * <li>[plane 1 byte] (only one plane accepted per instance)
 * <li>[numLengthBits 1 byte] (the # of bits to code the big_index values
 * <li>[numLetterbits 1 byte] (the # of bits to code the small_index values
 * <li>[max length 2 bytes] (the maximum word length currently coded in the table
 * <li>[numWords 3 bytes] (total number of words
 * <li>[dataoffset 2 bytes] (relative pointer to packed data below. pre compute the length of the table.)
 * <br>
 * <br>
 * 
 * (big_index = the # of words of that given length)
 * 
 * <br>
 * (small_index = # of words of that length startig with the nth letter)<br>
 * [length=1 char big_index] [ (1st letter small_index) (2nd letter small_index) (3rd...) ... ]<br>
 * [length=2 char big_index] [ (1st letter small_index) (2nd letter small_index) ... ]<br>
 * <br>
 * <br>
 * Where to store different plane?
 * When a different plane is detected, generate a warning and morph to build
 * @author Charles Bentley
 *
 */
public class PowerCharColRun extends PowerCharCol implements IPowerCharCollector, ITechCharColRun {

   /**
    * Maps a String to its position in this structure.
    * <br>
    * <br>
    * 
    */
   protected IPowerLinkStringToBytes indexx;

   /**
    * Where do we set sub instance id?
    * What about groupid that belongs?
    * <br>
    * <br>
    * Why not serializing everything inside the same byte array? Why the dissociation
    * when there is no need for one. Nothing is shared between instances.
    * 
    */
   private IPowerIntArrayOrderToInt  lettersAll;

   /**
    * Tracks first letters. Allows to quickly know the index position of a letter with {@link IPowerLinkOrderedIntToInt#getValueOrderCount(int)}
    */
   private IPowerIntArrayOrderToInt  lettersFirst;

   private Vector                    pointerUsers;

   /**
    * Init with a default Header generated by the 
    * plane is zero
    */
   public PowerCharColRun(PDCtx pdc) {
      this(pdc, pdc.getTechFactory().getPowerCharRunTechRoot());
   }

   /**
    * 
    * @param pdc
    * @param tech
    */
   public PowerCharColRun(PDCtx pdc, ByteObjectManaged tech) {
      super(pdc, tech);
      setFlag(AGENT_OFFSET_01_FLAG_1, AGENT_FLAG_CTRL_7_DATA_UNLOADED, true);
   }

   //   /**
   //    * default constructor. it creates the default header
   //    * 8 bits for the small index code
   //    */
   //   public PowerCharColRun(PDCtx pdc, int plane) {
   //      super(pdc, new byte[CHAR_RUN_BASIC_SIZE + 2], 0);
   //      //create the start letter struct
   //      setStartLetters(new PowerOrderedIntToIntRun(mod));
   //      //now the all letters struct
   //
   //      allLetters = new PowerOrderedIntToIntRun(mod);
   //      //sets instance id here?
   //
   //      data[index + CHAR_RUN_OFFSET_02_SMALL_INDEX_BIT] = 1;
   //      //originally there is the bigindex for length 1 = 0
   //      MUtils.addShort(data, index + CHAR_RUN_OFFSET_08_DATA_OFFSET2, index + (CHAR_RUN_BASIC_SIZE + 2) * 8);
   //      data[index + CHAR_RUN_OFFSET_03_MAX_LENGTH2] = 1;
   //      data[index + CHAR_RUN_OFFSET_00_PLANE1] = (byte) plane;
   //      //the table header
   //      headerTableOffset = index + CHAR_RUN_BASIC_SIZE;
   //      smallIndexValueBitSize = startLetters.getSize() * getSmallIndexNumBits();
   //      letterBitSizeVal = BitMask.widthInBits(allLetters.getSize());
   //      initCCC();
   //   }

   public void addPointerUser(IPointerUser pointerUser) {
      if (pointerUsers == null) {
         pointerUsers = new Vector();
      }
      pointerUsers.addElement(pointerUser);
   }

   private void copyMyChars(char[] cars, int offset, int len, BitCoordinate c, int firstLetterPosition) {
      int plane = getHeaderPlane();
      int letterBitSizeVal = getLetterBitSize();
      cars[offset] = CharUtils.buildCharFromLowByte(lettersFirst.getValueFromPosition(firstLetterPosition), plane);
      for (int i = 1; i < len; i++) {
         int position = getBU().readBits(data, c, letterBitSizeVal);
         int value = lettersAll.getValueFromPosition(position);
         if (value == Integer.MAX_VALUE) {
            //#debug
            printDataStruct("PowerCharColRun#copyMyChars letter position not acceptable " + position);
         }
         //System.out.println("value="+value + " from position:"+position);
         cars[offset + i] = CharUtils.buildCharFromLowByte(value, plane);
      }
   }

   /**
    * PRE:str hasn't been collected
    * computes the bits needed to add str word
    * and then expand the memory 
    * POST:
    * bit sizes for big and small index are updated
    * array is expanded
    * table is updated
    * @param str
    * @param offset
    * @param len
    */
   private void expandForNewWord(char[] str, int offset, int len) {
      //remember the old maximum length
      int maxlenold = getMaxLength();
      //this is the new maximum length
      int newmaxlen = maxlenold;
      boolean lengthIncreased = false;
      int lendiff = 0;
      if (len > maxlenold) {
         newmaxlen = len;
         lendiff = len - maxlenold;
         lengthIncreased = true;
      }
      int bitsneeded_fornewletter = 0;
      int bitsneeded_for_letterbitsincrease = 0;
      int bitsneeded_forsmallindexincrease = 0;
      int bitsneeded_forlengthupgrade = 0;
      int letterBitSizeVal = getLetterBitSize();
      int newletterbitsize = letterBitSizeVal;
      int totalNumberOfLetters = getTotalNumberOfLetters();
      int lastusedloadedbit = getLastUsedLoadedBit();
      int startletteroldsize = lettersFirst.getSize();
      int oldletterbits = letterBitSizeVal;
      int oldsize = lettersAll.getSize();
      IntBuffer newoffset = new IntBuffer(pdc.getUCtx());

      //this value is FIXED at 16 bits
      int bigIndexNumBits = getBigIndexNumBits();

      //this value might change if the number of startLetter/Len pairs increase over the bitsize
      int smallIndexBits = getSmallIndexNumBits();
      int oldsmallIndexBits = smallIndexBits;
      int newsmallIndexBits = smallIndexBits;
      if (!lengthIncreased) {
         //check if we have to increase small indexes bit size (big index bitsize is fixed 16bits)
         int val = getSmallIndex(str[offset], len);
         int diff = getBU().widthInBits(val + 1) - smallIndexBits;
         if (diff == 1) {
            bitsneeded_forsmallindexincrease = diff * (newmaxlen * lettersFirst.getSize());
            newsmallIndexBits++;
         }
      } else {
         if (smallIndexBits == 0)
            throw new RuntimeException();
      }
      //for the current length
      //count new letters and add the new
      int countnew = 0;
      for (int i = 0; i < len; i++) {
         int letter = str[i + offset] & 0xFF;
         if (i == 0) {
            if (!lettersFirst.hasValue(letter)) {
               //use old because if new max length, it will be computed
               bitsneeded_fornewletter = (newsmallIndexBits * maxlenold);
               //we don't have to worry about smallIndexbits because initially we have a value of 0
               //but we have to add it
               //System.out.println(_startLetters.toString());
               //#debug
               printDataStruct("PowerCharColRun#expandNewWord Adding Start letter Value=" + letter);

               lettersFirst.addValue(letter);
               //System.out.println(_startLetters.toString());

            }
         }
         if (!lettersAll.hasValue(letter) && !newoffset.contains(letter)) {
            countnew++;
            newoffset.addInt(letter);
         }

      }
      //#debug
      printDataStruct("countnew = " + countnew);
      newletterbitsize = getBU().widthInBits(oldsize + countnew);
      int diff = newletterbitsize - letterBitSizeVal;
      bitsneeded_for_letterbitsincrease = totalNumberOfLetters * diff;

      letterBitSizeVal = newletterbitsize;
      //#debug
      printDataStruct("_letterBitSize=" + letterBitSizeVal + " totalNumberOfLetters=" + totalNumberOfLetters);

      //update the offset after the possible increase in _offset
      int headerTableOffset = getHeaderTableOffsetLoaded();
      int smallIndexValueBitSize = getSmallIndexBitsConsumed();

      //expand for the length difference. this must be executed after bits upgrades at the level
      //of the small index and the new letters

      if (lengthIncreased) {
         int startletter_newsize = lettersFirst.getSize();
         //fill with only zeros.
         bitsneeded_forlengthupgrade = lendiff * (bigIndexNumBits + (startletter_newsize * newsmallIndexBits));
      }
      //update what can be updated now
      int bitsneedforword = ((len - 1) * newletterbitsize);
      int totalbits = bitsneeded_fornewletter + bitsneeded_for_letterbitsincrease + bitsneedforword + bitsneeded_forsmallindexincrease + bitsneeded_forlengthupgrade;
      //System.out.println(this);
      //this method may change offset and lastused bits
      //#debug
      printDataStruct("Shift bits from " + (getStringDataOffsetLoaded() + 1) + " to " + lastusedloadedbit);

      int oldf = index;
      expandArray((totalbits / 8) + 1);
      int bitdiff = (index - oldf) * 8;
      lastusedloadedbit += bitdiff;
      //System.out.println(this);
      //updateOffsets();
      //bits needed to upgrade the lookup table
      int tableShiftsize = bitsneeded_fornewletter + bitsneeded_forsmallindexincrease + bitsneeded_forlengthupgrade;
      System.out.println("Expansion bit shiftsize=" + tableShiftsize + " bitsneeded_fornewletter=" + bitsneeded_fornewletter + " bitsneeded_forsmallindexincrease=" + bitsneeded_forsmallindexincrease + " bitsneeded_forlengthupgrade=" + bitsneeded_forlengthupgrade);
      System.out.println("Shift bits from " + (getStringDataOffsetLoaded() + 1) + " to " + lastusedloadedbit);
      //update the _dataoffset because the table has grown
      //shift the databits to accept the new upgraded table
      getBU().shiftBitsUp(data, tableShiftsize, getStringDataOffsetLoaded() + 1, lastusedloadedbit, true);
      int dataBitOffset = getHeaderDataOffset() + tableShiftsize;
      //#debug
      printDataStruct("New dataBitOffset = " + dataBitOffset);
      set2(CHAR_RUN_OFFSET_08_DATA_OFFSET2, dataBitOffset);
      lastusedloadedbit += tableShiftsize;
      //now upgrade the letters
      BitCoordinate update = createBitCoordinate();
      int insertBitPosition = getStringDataOffsetLoaded();
      if (newletterbitsize != oldletterbits) {
         update.map(insertBitPosition);
         //this code must be tested with an upgrade
         //#debug
         printDataStruct("oldletterbits=" + oldletterbits + " newletterbitsize=" + newletterbitsize + " lastusedloadedbit=" + lastusedloadedbit);
         getBU().expandBitSize(data, update, totalNumberOfLetters, 0, oldletterbits, 0, newletterbitsize, lastusedloadedbit);
      }
      //remap to start
      for (int j = 0; j < newoffset.getIntsRef()[0]; j++) {
         update.map(insertBitPosition);
         lettersAll.addValue(newoffset.getIntsRef()[j + 1]);
         int position = lettersAll.getValueOrderCount(newoffset.getIntsRef()[j + 1]);
         for (int k = 0; k < totalNumberOfLetters; k++) {
            int val = getBU().readBits(data, update, letterBitSizeVal);
            //#debug
            printDataStruct("val=" + val + " basepos=" + position);
            if (val >= position) {
               update.rewind(letterBitSizeVal);
               getBU().copyBits(data, update, val + 1, letterBitSizeVal);
            }
         }
      }

      //done
      //upgrade the len: this is implicit
      //rewrite the table with updated first letters and the numbits of bits
      if (tableShiftsize != 0) {
         //read the whole table (big and small index). bitshift and rewrite it anew
         int letters = startletteroldsize;
         int newstartlettersize = lettersFirst.getSize();
         boolean newstarletter = false;
         if (newstartlettersize != startletteroldsize) {
            newstarletter = true;
         }
         int[] all = new int[newmaxlen * (newstartlettersize + 1)];
         int count = 0;
         BitCoordinate c = createBitCoordinate();
         //start at 1 and get over all up to maxlen
         int bit = getBitPositionBigIndex(1);
         c.map(bit);
         //read for the old table (old max length)
         int readlen = maxlenold;
         int firstlettervalue = str[offset] & 0xFF;
         for (int i = 1; i <= readlen; i++) {
            all[count] = getBU().readBits(data, c, bigIndexNumBits);
            count++;
            for (int j = 0; j < newstartlettersize; j++) {
               if (newstarletter && j + 1 == lettersFirst.getValueOrderCount(firstlettervalue)) {
                  all[count] = 0;
               } else {
                  all[count] = getBU().readBits(data, c, oldsmallIndexBits);
               }
               count++;
            }
         }
         //rewrite them all
         c.map(bit);
         count = 0;
         for (int i = 1; i <= newmaxlen; i++) {
            //System.out.println(all[count]);
            getBU().copyBits(data, c, all[count], bigIndexNumBits);
            count++;
            for (int j = 0; j < newstartlettersize; j++) {
               getBU().copyBits(data, c, all[count], newsmallIndexBits);
               count++;
            }
         }
      }
      //set smallIndexbits
      set1(CHAR_RUN_OFFSET_02_LETTER_BIT1, newsmallIndexBits);
      if (len > maxlenold) {
         set2(CHAR_RUN_OFFSET_03_MAX_LENGTH2, newmaxlen);
      }
      //System.out.println(toString());
   }



   /**
    * 
    * Gets the big_index value for length
    * @param length
    * @return
    */
   private int getBigIndex(int length) {
      BitCoordinate c = createBitCoordinate();
      c.map(getBitPositionBigIndex(length));
      return getBU().readBits(data, c, getBigIndexNumBits());
   }

   /**
    * getting the # of bits to code the LENGTH bit fields
    * <br>
    * <br>
    * Reads {@link PowerCharColRun#CHAR_RUN_OFFSET_01_BIG_INDEX_BIT}.
    * <br>
    * <br>
    * When 0 (means uncompressed) returns {@link PowerCharColRun#DEFAULT_BIG_INDEX_BITSIZE} usually 16 bits
    */
   private int getBigIndexNumBits() {
      int val = get1(CHAR_RUN_OFFSET_01_LENGTH_BIT1);
      if (val == 0) {
         return DEFAULT_BIG_INDEX_BITSIZE;
      }
      return val;
   }

   /**
    * 
    * <li>[0] = # words who length is smaller than <code>length</code>
    * <li>[1] = loaded bitPosition of length(big_index) header
    * <li>[2] = bits consumed by the data of lengths smaller than <code>length</code>
    * <br>
    * <br>
    * 
    * if the length is bigger than max length
    * <br>
    * <br>
    * @param length length of the word
    * @param vars result container
    */
   private void getBigIndexVariables(int length, int[] vars) {
      int val = 0;
      int bitsConsumed = 0;
      int lenv = length;
      if (length > getMaxLength()) {
         lenv = getMaxLength();
      }
      int letterBitSizeVal = getLetterBitSize();
      //should be pre-computed
      for (int i = 1; i < lenv; i++) {
         int numIndex = getBigIndex(i);
         bitsConsumed += ((i - 1) * letterBitSizeVal * numIndex);
         val += numIndex;

      }
      vars[0] = val;
      vars[1] = getBitPositionBigIndex(length);
      vars[2] = bitsConsumed;
      //System.out.println(bitsConsumed + " for len =" + length);
   }

   /**
    * loaded bitposition of big_index value for length
    * @param length
    * @return
    */
   private int getBitPositionBigIndex(int length) {
      int bits = (getHeaderTableOffsetLoaded()) * 8;
      int v = getBigIndexNumBits() + getSmallIndexBitsConsumed();
      bits += (length - 1) * v;
      return bits;
   }

   private int getHeaderDataOffset() {
      return get2(CHAR_RUN_OFFSET_08_DATA_OFFSET2);
   }

   private int getHeaderPlane() {
      return get1(CHAR_RUN_OFFSET_00_PLANE1);
   }

   private int getHeaderTableOffsetLoaded() {
      return index + CHAR_RUN_BASIC_SIZE;
   }

   public int getLastUsedLoadedBit() {
      int ln = getTotalNumberOfLetters();
      return getStringDataOffsetLoaded() + (getLetterBitSize() * ln);
   }

   private int getLetterBitSize() {
      return getBU().widthInBits(lettersAll.getSize());
   }

   public int getMaxLength() {
      return get2(CHAR_RUN_OFFSET_03_MAX_LENGTH2);
   }

   public Object getMorph(MorphParams p) {
      if (p.cl == IntToStrings.class) {
         IntToStrings its = new IntToStrings(pdc.getUCtx(), getSize());
         //iterate

      } else if (p.cl == PowerCharColBuild.class || p.type == ITechMorph.MODE_1_BUILD) {

      }
      return null;
   }

   private char[] getMyChars(int len, BitCoordinate c, int firstLetterPosition) {
      char[] ca = new char[len];
      copyMyChars(ca, 0, len, c, firstLetterPosition);
      return ca;
   }

   public int[] getNewPointers() {
      return null;
   }

   /**
    * Returns the number of words starting with <code>letter</code> of length len
    * <br>
    * <br>
    * 
    * @param letter
    * @param len
    */
   private int getSmallIndex(char letter, int len) {
      int letterValue = letter & 0xFF;
      int pos = getBitPositionBigIndex(len);
      pos += getBigIndexNumBits();
      int letterIndexCount = lettersFirst.getValueOrderCount(letterValue);
      int numBitsSmallIndex = getSmallIndexNumBits();
      pos += (letterIndexCount - 1) * numBitsSmallIndex;
      //bit coordinate to read bits
      BitCoordinate c = createBitCoordinate();
      c.map(pos);
      return getBU().readBits(data, c, numBitsSmallIndex);
   }

   /**
    * loadedposition for reading the first word of length starting with 
    * @param len
    * @param letterPosition
    * @return
    */
   public int getSmallIndexBitPosition(char letter, int len) {
      int firstLetterValue = letter & 0xFF;
      int letterPosition = lettersFirst.getValueOrderCount(firstLetterValue);
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1] + getBigIndexNumBits());
      int alphaStartSize = lettersFirst.getSize();
      int firstLetterPosition = 0;
      int numIndex = vars[0] + getBigIndex(len);
      int passed = 0;
      for (int i = 1; i < letterPosition; i++) {
         firstLetterPosition++;
         //read the number of words of length starting with ith letter
         int num = getBU().readBits(data, c, getSmallIndexNumBits());
         numIndex += num;
         passed += num;
      }
      return vars[1] + passed;
   }

   /**
    * The bit size of a row of numIndex for any length
    * <br>
    * To code this  
    * [ (1st letter small_index value) (2nd letter small_index) (3rd...) ... ]
    */
   private int getSmallIndexBitsConsumed() {
      return lettersFirst.getSize() * getSmallIndexNumBits();
   }

   /**
    * return the number of words below letter/len doublon
    * @param letter
    * @param len
    * @return
    */
   private int getSmallIndexNumBelow(char letter, int len) {
      int firstLetterValue = letter & 0xFF;
      int letterPosition = lettersFirst.getValueOrderCount(firstLetterValue);
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1] + getBigIndexNumBits());
      int numIndexBelow = vars[0];
      for (int i = 1; i < letterPosition; i++) {
         //read the number of words of length starting with ith letter
         int num = getBU().readBits(data, c, getSmallIndexNumBits());
         numIndexBelow += num;
      }
      return numIndexBelow;
   }

   /**
    * Returns the number of bits used to code the small_index
    * <br>
    * <br>
    * Reads {@link PowerCharColRun#CHAR_RUN_OFFSET_02_SMALL_INDEX_BIT}
    */
   private int getSmallIndexNumBits() {
      return get1(CHAR_RUN_OFFSET_02_LETTER_BIT1);
   }

   public int[][] getSmallValues() {
      return null;
   }

   /**
    * the loaded bit position for reading the first word starting with letter
    * of length len
    * @param letter
    * @param len
    * @return
    */
   private int getStartBitPosition(char letter, int len) {
      int bits = getStringDataOffsetLoaded();
      int letterBitSizeVal = getLetterBitSize();
      for (int i = 1; i < len; i++) {
         int bigi = getBigIndex(i);
         bits += (i - 1) * bigi * letterBitSizeVal;
      }

      int firstLetterValue = letter & 0xFF;
      int letterPosition = lettersFirst.getValueOrderCount(firstLetterValue);
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1] + getBigIndexNumBits());
      //System.out.println("letterPosition="+letterPosition);
      for (int i = 1; i < letterPosition; i++) {
         //read the number of words of length starting with ith letter
         int num = getBU().readBits(data, c, getSmallIndexNumBits());
         bits += num * (len - 1) * letterBitSizeVal;
      }
      return bits;
   }

   public IPowerIntArrayOrderToInt getStartLetters() {
      return lettersFirst;
   }

   public int getStringDataOffsetLoaded() {
      return get2(CHAR_RUN_OFFSET_08_DATA_OFFSET2);
   }

   /**
    * number of letters stored
    * @return
    */
   public int getTotalNumberOfLetters() {
      int val = 0;
      for (int i = 1; i <= getMaxLength(); i++) {
         val += getBigIndex(i) * (i - 1);
      }
      return val;
   }

   /**
    * Increment by one the big and small index corresponding to the duo letter/length
    * <br>
    * 
    * @param letter
    * @param len
    */
   private void incrementIndexes(char letter, int len) {
      int firstLetterValue = letter & 0xFF;
      int letterPosition = lettersFirst.getValueOrderCount(firstLetterValue);
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1]);
      int bigbits = getBigIndexNumBits();
      int num = getBU().readBits(data, c, bigbits);
      num++;
      c.rewind(bigbits);
      System.out.println(getBigIndex(len));
      getBU().copyBits(data, c, num, bigbits);
      int smalbits = getSmallIndexNumBits();
      c.forward(getSmallIndexNumBits() * (letterPosition - 1));
      num = getBU().readBits(data, c, smalbits);
      num++;
      c.rewind(smalbits);
      getBU().copyBits(data, c, num, smalbits);
   }

   protected void initEmptyConstructor() {
      super.initEmptyConstructor();
      initEmpty();
   }

   /**
    * Find the {@link IPowerLinkOrderedIntToInt} for this {@link PowerCharColRun}.
    * <br>
    * <br>
    * Implementation is unknown. Use Factory class with genetics code. Where do we get the genes?
    * Implementation details of {@link PowerCharColRun}.
    * <br>
    * <br>
    * Is the serialization always the same?
    */
   private void initEmpty() {
      initSubs();
      buildIndex();
   }

   private void initSubs() {
      int refAll = get2(CHAR_RUN_OFFSET_10_REFID_ALLLETTER2);
      lettersAll = (IPowerIntArrayOrderToInt) byteCon.getAgentFromRefOrCreate(refAll, IPowerIntArrayOrderToInt.INT_ID);
      int refStart = get2(CHAR_RUN_OFFSET_09_REFID_FIRSTLETTER2);
      lettersFirst = (IPowerIntArrayOrderToInt) byteCon.getAgentFromRefOrCreate(refStart, IPowerIntArrayOrderToInt.INT_ID);
   }

   protected int insideAddChars(char[] str, int offset, int len) {
      if (!StringUtils.isFullPlane(getHeaderPlane(), str, offset, len)) {
         //create a CharCol for this plane. if mixed plane,
         throw new RuntimeException();
      }
      int pointer = insideFind(str, offset, len);
      //check if it is already there
      if (pointer != IPowerCharCollector.CHARS_NOT_FOUND) {
         return pointer;
      }
      expandForNewWord(str, offset, len);
      //what we know already. the table is updated. now we need to find bit coordinate
      //where we will write the word.
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      BitCoordinate c = createBitCoordinate();
      int bit = getStartBitPosition(str[offset], len);
      int smallIndexNumWords = getSmallIndex(str[offset], len);
      int smallIndexNumBelow = getSmallIndexNumBelow(str[offset], len);
      c.map(bit);
      //#debug
      printDataStruct("Insertion bit=" + bit + " smallIndexNumBelow=" + smallIndexNumBelow);
      int insertBitPosition = bit;
      int letterBitSizeVal = getLetterBitSize();
      //look for a word fully smaller, then add itself before it
      for (int i = 0; i < smallIndexNumWords; i++) {
         c.map(insertBitPosition);
         boolean found = true;
         for (int j = 1; j < len; j++) {
            int letteval = (str[j] & 0xFF);
            int cv = getBU().readBits(data, c, letterBitSizeVal);
            if (cv < letteval) {
               smallIndexNumBelow++;
               found = false;
               //check next words
               break;
            }
            //full equality cannot occur because of the check above
         }
         if (found) {
            break;
         } else {
            insertBitPosition += letterBitSizeVal * (len - 1);
         }
      }
      //#debug
      printDataStruct("Insertion bit=" + bit + " smallIndexNumBelow=" + smallIndexNumBelow);

      //get our bit position and expand by bitshifting.
      //insert bit position + 1 because method includes it
      getBU().shiftBitsUp(data, letterBitSizeVal * (len - 1), insertBitPosition + 1, getLastUsedLoadedBit(), true);
      IntUtils.writeInt24BE(data, index + CHAR_RUN_OFFSET_04_NUM_WORD3, getSize() + 1);
      incrementIndexes(str[offset], len);
      //#debug
      printDataStruct("After bit shift");
      c.map(insertBitPosition);
      for (int i = 1; i < len; i++) {
         int letterval = str[i] & 0xFF;
         int pos = lettersAll.getValueOrderCount(letterval);
         getBU().copyBits(data, c, pos, letterBitSizeVal);
      }
      //System.out.println(toString());
      //System.out.println(toString());
      //return pointer for inserted word
      return smallIndexNumBelow + 1;
   }

   protected void insideAppendChars(int pointer, StringBBuilder sb) {
      char[] cs = getChars(pointer);
      sb.append(cs);
   }

   protected int insideCopyChars(int pointer, char[] cars, int offset) {
      int len = getLen(pointer);
      if (len == -1)
         return 0;
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      int numIndex = vars[0];
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1] + getBigIndexNumBits());
      int alphaStartSize = lettersFirst.getSize();
      int firstLetterPosition = 0;
      int passed = 0;
      int letterBitSizeVal = getLetterBitSize();
      for (int i = 1; i <= alphaStartSize; i++) {
         firstLetterPosition++;
         int num = getBU().readBits(data, c, getSmallIndexNumBits());
         numIndex += num;
         if (pointer <= numIndex) {
            int forw = letterBitSizeVal * (len - 1) * (num - (numIndex - pointer) - 1);
            forw += letterBitSizeVal * (len - 1) * passed;
            c.map((getStringDataOffsetLoaded()) + vars[2] + forw);
            break;
         }
         passed += num;
      }
      copyMyChars(cars, offset, len, c, firstLetterPosition);
      return len;
   }

   protected int insideFind(char[] str, int offset, int len) {
      if (len > getMaxLength()) {
         return -1;
      }
      int value = IPowerCharCollector.CHARS_NOT_FOUND;
      if (indexx != null) {
         byte[] d = indexx.find(str, offset, len);
         if (d.length == 0) {
            value = IPowerCharCollector.CHARS_NOT_FOUND;
         } else {
            value = IntUtils.readIntBE(d, 0);
         }
         return value;
      }
      //get the length of our word
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      //map the bit position to start reading
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1]);
      int firstLetterValue = str[offset] & 0xFF;
      int firstLetterPosition = lettersFirst.getValueOrderCount(firstLetterValue);
      if (firstLetterPosition == 0)
         return -1;
      int letterBitSizeVal = getLetterBitSize();
      //get small_index value
      int smallIndexBits = getSmallIndexNumBits();
      //read the number of words of length starting with ith letter
      int numWords = getBU().readBits(data, c, getBigIndexNumBits());
      //compute num below that letter
      int numBelowLetter = 0;
      for (int i = 1; i < firstLetterPosition; i++) {
         numBelowLetter += getBU().readBits(data, c, smallIndexBits);
      }
      int pointer = vars[0] + numBelowLetter;
      int forw = (letterBitSizeVal * numBelowLetter * (len - 1));
      c.map(getStringDataOffsetLoaded() + vars[2] + forw);

      //iterate over the number of words starting with that letter
      for (int j = 0; j < numWords; j++) {
         char[] cr = getMyChars(len, c, firstLetterPosition);
         boolean found = true;
         for (int i = 0; i < cr.length; i++) {
            if (str[offset + i] != cr[i]) {
               found = false;
               break;
            }
         }
         pointer++;
         if (found)
            return pointer;
      }
      return IPowerCharCollector.CHARS_NOT_FOUND;
   }

   protected char insideGetChar(int pointer) {
      int len = getLen(pointer);
      if (len == -1)
         return ' ';
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      int numIndex = vars[0];
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1] + getBigIndexNumBits());
      int alphaStartSize = lettersFirst.getSize();
      int firstLetterPosition = 0;
      int numLetterBits = getSmallIndexNumBits();
      for (int i = 1; i <= alphaStartSize; i++) {
         firstLetterPosition++;
         numIndex += BitUtils.readBits(data, c, numLetterBits);
         if (pointer <= numIndex) {
            break;
         }
      }
      //get the char value as a integer
      int charIntValue = lettersFirst.getValueFromPosition(firstLetterPosition);
      return CharUtils.buildCharFromLowByte(charIntValue, data[index + CHAR_RUN_OFFSET_00_PLANE1]);
   }

   protected char[] insideGetChars(int pointer) {
      if (pointer <= 0)
         return "".toCharArray();
      //get the length of our word
      int len = getLen(pointer);
      if (len == -1)
         return "".toCharArray();
      int[] vars = new int[3];
      getBigIndexVariables(len, vars);
      int numIndex = vars[0];
      BitCoordinate c = createBitCoordinate();
      c.map(vars[1] + getBigIndexNumBits());
      int alphaStartSize = lettersFirst.getSize();
      int firstLetterPosition = 0;
      //the number of words gone by
      int passed = 0;
      int letternumbits = getSmallIndexNumBits();
      int letterBitSizeVal = getLetterBitSize();
      for (int i = 1; i <= alphaStartSize; i++) {
         firstLetterPosition++;
         //read the number of words of length starting with ith letter
         int num = getBU().readBits(data, c, letternumbits);
         numIndex += num;
         if (pointer <= numIndex) {
            //based on the pointer create the coordinate to read our word
            int forw = letterBitSizeVal * (len - 1) * (num - (numIndex - pointer) - 1);
            forw += letterBitSizeVal * (len - 1) * passed;
            //vars[2] is the bits consumed by data below. forward is the bits
            c.map(getStringDataOffsetLoaded() + vars[2] + forw);
            break;
         }
         passed += num;
      }
      return getMyChars(len, c, firstLetterPosition);
   }

   protected char[] insideGetChars(int[] charp) {
      int size = 0;
      for (int i = 0; i < charp.length; i++) {
         size += insideGetLen(charp[i]);
      }
      char[] val = new char[size];
      int off = 0;
      for (int i = 0; i < charp.length; i++) {
         off += insideCopyChars(charp[i], val, off);
      }
      return val;
   }

   protected String insideGetKeyStringFromPointer(int pointer) {
      return new String(this.insideGetChars(pointer));
   }

   /**
    * 
    * @param pointer
    * @return
    */
   protected int insideGetLen(int pointer) {
      //starts at 1
      if (pointer <= 0)
         return -1;
      int sum = 0;
      int maxl = getMaxLength();
      for (int i = 1; i <= maxl; i++) {
         sum += getBigIndex(i);
         if (pointer <= sum) {
            return i;
         }
      }
      return -1;
   }

   protected int insideGetPointer(char[] chars, int offset, int len) {
      return insideFind(chars, offset, len);
   }

   protected int[][] insideGetSizes() {
      if (insideGetSize() == 0) {
         return new int[1][];
      }
      return null;
   }

   protected boolean insideHasChars(char[] chars, int offset, int len) {
      return IPowerCharCollector.CHARS_NOT_FOUND != insideFind(chars, offset, len);
   }

   /**
    * remove means that all pointers above must be reduced by one
    * only remove the bits used by the word
    * <br>
    * Flag the word as removed
    */
   protected int insideRemove(int pointer, boolean useForce) {
      //TODO implement it
      return 0;
   }

   /**
    * Remove all Strings, Then add new 
    * Special Add trying to reuse the slot pointer
    */
   protected int insideSetChars(int pointer, char[] d, int offset, int len) {
      return -1;
   }

   /**
    * 
    */
   public boolean isValid(int pointer) {
      return false;
   }

   public void search(CharSearchSession css) {
      // TODO Auto-generated method stub

   }

   private byte[] serializeRaw() {
      return toByteArray();
   }

   public void serializeReverse() {
      initEmpty();
   }

   public ByteObjectManaged serializeTo(ByteController byteCon) {
      ByteObjectManaged bom = byteCon.serializeToUpdateAgentData(serializeRaw());
      lettersAll.serializeTo(byteCon);
      bom.set2(CHAR_RUN_OFFSET_10_REFID_ALLLETTER2, lettersAll.getTech().getIDRef());
      lettersFirst.serializeTo(byteCon);
      bom.set2(CHAR_RUN_OFFSET_09_REFID_FIRSTLETTER2, lettersFirst.getTech().getIDRef());
      return bom;
   }

   public void setStartLetters(IPowerIntArrayOrderToInt _startLetters) {
      this.lettersFirst = _startLetters;
   }

   public String toString() {
      return toString("\n\t");
   }

   public String toString(String nl) {
      String nnl = nl + "\t";
      StringBBuilder sb = new StringBBuilder(pdc.getUCtx());
      try {
         int tablebitsize = (getBigIndexNumBits() + lettersFirst.getSize() * getSmallIndexNumBits()) * getMaxLength();
         sb.append("#PowerCharColRun");
         sb.append(nl);
         sb.append(" Table Size=" + ((getStringDataOffsetLoaded()) - ((index + CHAR_RUN_BASIC_SIZE) * 8)) + " bits " + " should be = " + tablebitsize);
         int plane = getHeaderPlane();
         sb.append(nl);
         sb.append("NotLoaded=" + getHeaderDataOffset() + " LoadedDataBitOffset=" + getStringDataOffsetLoaded() + " bits (" + getStringDataOffsetLoaded() / 8 + " bytes) MaxLength:" + getMaxLength() + " NumWord:" + getSize() + " Plane:" + plane);
         sb.append(nl);
         sb.append("First Letters:(" + lettersFirst.getSize() + ")\t");
         //sb.append(_startLetters.toString());
         int[] vals = lettersFirst.getValues();
         for (int i = 0; i < vals.length; i++) {
            sb.append(CharUtils.buildCharFromLowByte(vals[i], plane));
            sb.append(',');
         }
         sb.append(nl);
         sb.append("All Letters: (" + lettersAll.getSize() + ")\t");
         vals = lettersAll.getValues();
         for (int i = 0; i < vals.length; i++) {
            sb.append(CharUtils.buildCharFromLowByte(vals[i], plane));
            sb.append(',');
         }
         //now prints the header table
         sb.append(nl);
         sb.append("Letter bitsize=" + getLetterBitSize() + " ");
         sb.append(" BigIndex BitSize=" + getBigIndexNumBits() + " bits. SmallIndex BitSize=" + getSmallIndexNumBits() + " bits ");

         BitCoordinate c = new BitCoordinate(pdc.getUCtx(), getHeaderTableOffsetLoaded(), 0);
         for (int i = 1; i <= getMaxLength(); i++) {
            int num = getBU().readBits(data, c, getBigIndexNumBits());
            sb.append(nl);
            sb.append("len " + i + "\t Big=" + num);
            int firstLettersNum = lettersFirst.getSize();
            for (int j = 1; j <= firstLettersNum; j++) {
               num = getBU().readBits(data, c, getSmallIndexNumBits());
               //c.forward(wordPointerBits);
               char mc = CharUtils.buildCharFromLowByte(lettersFirst.getValueFromPosition(j), plane);
               sb.append("\t Small=" + num + " (" + mc + ")");
            }
            //c.forward(skipBitsSize);
         }
         sb.append(nl);
         for (int i = 1; i <= getSize(); i++) {
            sb.append(new String(getChars(i)) + ",");
            if (i % 10 == 0)
               sb.append(nl);
         }
         sb.append(nl);
      } catch (Exception e) {
         sb.append(nl);
         sb.append("Exception " + e.getClass().getName() + " Message=" + e.getMessage());
         //e.printStackTrace();
      }
      return sb.toString();
   }

}
